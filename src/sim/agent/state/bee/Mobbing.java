package sim.agent.state.bee;

import sim.Coordinate;
import sim.Mob;
import sim.agent.Agent;
import sim.agent.Bee;
import sim.agent.state.State;
import sim.config.Defaults;

import java.util.Random;

/**
 * The Mobbing State models the defensive behaviour of A. Cerana when the bee is performing it's hot defensive bee ball
 * maneuver. In this behaviour, the bee attempts to form a mob around a given threat, preventing it from moving and
 * killing it via the heat generated by the ball.
 *
 */
public class Mobbing extends State {

    private Agent target;
    private Mob mob;
    private boolean leaving;

    /**
     * Class constructor.
     * Assigns the parent agent to a mob.
     * @param parent The agent currently using this state
     * @param target The target agent which the parent agent will attempt to form a mob around
     */
    public Mobbing(Agent parent, Agent target) {
        super(parent);
        this.target = target;
        this.mob = parent.getParent().getMob();
        this.leaving = false;
        if(!mob.contains(parent)){
            this.mob.add(parent);
        }
    }

    /**
     * The GetTarget function in the mobbing behaviour focuses on finding a valid location to which the agent should move
     * based on forming a ball around the perceived threat.
     * If the temperature is too high for the bee it will attempt to leave.
     * This is achieved by setting the agents goal a short distance away from the centre of the mob. Upon reaching its goal
     * distance from the mob the agent will return to a guarding state and stay near the threat.
     * If the target is dead the agent will attempt to disperse and return to a working state.
     * @return Absolute location to which the agent will attempt to move
     */
    @Override
    public Coordinate GetTarget() {
        //Check to see if the target is dead so the agent can stop mobbing
        if(target.getHP() <= 0){
            if(parent.getLocation().DistanceTo(target.getLocation()) > parent.getOptions().getPerceptionDistance()/2){
                parent.setState(new Working(parent, parent.getOptions().getCohesionRate()));
                return parent.getLocation();
            }
            else{
                return GetBestVector(LeaveMobVector());
            }
        }
        //Here we calculate if we have successfully left the mob. If we have we move into the guarding state,
        //otherwise we return the best current vector for leaving.
        if(leaving){
            if(parent.getLocation().DistanceTo(target.getLocation()) > parent.getOptions().getPerceptionDistance()/2){
                mob.modifyCurrentlyLeaving(-1);
                Guarding nextState = new Guarding(parent);
                nextState.setThreat(target);
                parent.setState(nextState);
                return GetBestVector(target.getLocation());
            }
            else{
                return GetBestVector(LeaveMobVector());
            }
        }
        //If the temp is too high, try to leave
        parent.setTemperature(mob.getTemperature());
        if(parent.getTemperature() >= Defaults.BEE_LETHAL_TEMPERATURE - 2){
            Coordinate leavingVector = LeaveMobVector();
            if(GetBestVector(leavingVector).Equals(parent.getLocation())){
                return GetBestVector(target.getLocation());
            }
            else if(mob.getCurrentlyLeaving() < 3) {
                mob.modifyCurrentlyLeaving(1);
                leaving = true;
                return GetBestVector(LeaveMobVector());
            }
            else{
                return GetBestVector(target.getLocation());
            }
        }
        else{
            return GetBestVector(target.getLocation());
        }
    }

    /**
     * Get a vector in the opposite direction of the centre of the mob, thus giving the agent a target that will lead
     * them away from the threat.
     * @return Coordinate, the sum of a vector facing away from the threat and parent's current location
     */
    public Coordinate LeaveMobVector(){
        //get the vector to center of the mob, will be the location of the hornet
        Coordinate centerOfMob = VectorToTarget(parent.getLocation(), parent.getPerceptor().getThreat().getLocation());
        //reverse target vector direction
        Coordinate leaveVector = new Coordinate();
        if (centerOfMob .X() != 0) {
            leaveVector.setX(centerOfMob .X() * -1);
        }
        if (centerOfMob .Y() != 0) {
            leaveVector.setY(centerOfMob .Y() * -1);
        }
        //Sum for absolute location
        return new Coordinate(leaveVector.X() + parent.getLocation().X(), leaveVector.Y() + parent.getLocation().Y());
    }
}
